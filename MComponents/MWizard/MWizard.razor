
@implements IMWizard

@using System.Threading;
@using System.Threading.Tasks;

<CascadingValue TValue="MWizard" Value="this">

    @Steps

    <div class="kt-grid kt-wizard-v3 kt-wizard-v3--white" id="kt_wizard_v3" data-ktwizard-state="@GetCurrentState()">
        <div class="kt-grid__item">
            <!--begin: Form Wizard Nav -->
            <div class="kt-wizard-v3__nav">
                <div class="kt-wizard-v3__nav-items">

                    @{
                        int i = 0;
                        int visible = 1;
                        int visibleCount = mSteps.Count(s => s.IsVisible);
                    }
                    @foreach (var entry in mSteps)
                    {

                        if (entry.IsVisible)
                        {
                            string state = "pending";

                            if (i == CurrentStep)
                                state = "current";

                            int index = i; //deep copy for onclick lambda

                            bool canJump = CanJumpTo(i);

                            <div class="kt-wizard-v3__nav-item" data-ktwizard-type="step" data-ktwizard-state="@state" style="flex: 0 0 calc(100%/@visibleCount); @(!FreezeCurrentStep && canJump ? "cursor: pointer;": "cursor: default;")" @onclick="() => OnJumpToClicked(index)">
                                <div class="kt-wizard-v3__nav-body">
                                    <div class="kt-wizard-v3__nav-label">
                                        <span>@visible</span> @entry.Title
                                    </div>
                                    <div class="kt-wizard-v3__nav-bar"></div>
                                </div>
                            </div>
                            visible++;
                        }

                        i++;
                    }


                </div>
            </div>
            <!--end: Form Wizard Nav -->
        </div>

        <div class="kt-grid__item kt-grid__item--fluid kt-wizard-v3__wrapper">

            <div class="kt-form">

                @if (CurrentStep >= 0 && mSteps.Count > CurrentStep)
                {
                    <div class="kt-wizard-v3__content" data-ktwizard-type="step-content" data-ktwizard-state="current">
                        @mSteps[CurrentStep].Content
                    </div>
                }

                @if (!FreezeCurrentStep)
                {
                    <div class="kt-form__actions">
                        <MWizardPrevStep />
                        <MWizardFinishStep />
                        <MWizardNextStep />
                    </div>
                }

            </div>
        </div>
    </div>

</CascadingValue>


@code {

    [Parameter]
    public RenderFragment Steps { get; set; }

    [Parameter]
    public EventCallback<StepChangedArgs> OnStepChanged { get; set; }

    [Parameter]
    public EventCallback<SubmitEventArgs> OnSubmit { get; set; }

    [Parameter]
    public bool EnableJumpToAnyStep { get; set; }


    public bool FreezeCurrentStep { get; set; }

    public int CurrentStep { get; protected set; }


    protected List<MWizardStep> mSteps = new List<MWizardStep>();


    protected SemaphoreSlim mLocker = new SemaphoreSlim(1, 1);


    public void RegisterStep(MWizardStep pStep)
    {
        if (mSteps.Any(s => s.Identifier == pStep.Identifier))
            return;

        mSteps.Add(pStep);

        if (CurrentStep == -1 && pStep.IsVisible)
            CurrentStep = mSteps.Count - 1;

        StateHasChanged();
    }

    internal async void OnNextClicked()
    {
        if (FreezeCurrentStep)
            return;

        await mLocker.WaitAsync();

        try
        {
            int oldStep = CurrentStep;

            int? next = FindNextVisible(CurrentStep, i => i + 1);
            if (!next.HasValue)
                return;

            int newStep = next.Value;

            var args = new StepChangedArgs()
            {
                OldStepIndex = oldStep,
                NewStepIndex = newStep,
                OldStep = mSteps[oldStep],
                NewStep = mSteps[newStep],
                UserInteract = true
            };

            await OnStepChanged.InvokeAsync(args);
            //   task.Wait();

            if (args.Cancelled)
                return;

            CurrentStep = newStep;

            StateHasChanged();
        }
        finally
        {
            mLocker.Release();
        }
    }

    internal async void OnPrevClicked()
    {
        if (FreezeCurrentStep)
            return;

        await mLocker.WaitAsync();
        try
        {
            int oldStep = CurrentStep;

            int? prev = FindNextVisible(CurrentStep, i => i - 1);
            if (!prev.HasValue)
                return;

            int newStep = prev.Value;

            var args = new StepChangedArgs()
            {
                OldStepIndex = oldStep,
                NewStepIndex = newStep,
                OldStep = mSteps[oldStep],
                NewStep = mSteps[newStep],
                UserInteract = true
            };

            await OnStepChanged.InvokeAsync(args);

            if (args.Cancelled)
                return;

            CurrentStep = newStep;

            StateHasChanged();
        }
        finally
        {
            mLocker.Release();
        }
    }

    protected void OnJumpToClicked(int pIndex)
    {
        if (FreezeCurrentStep)
            return;

        if (!CanJumpTo(pIndex))
            return;

        SetCurrentStep(pIndex, true);
    }


    internal async void OnFinishClicked()
    {
        if (FreezeCurrentStep)
            return;

        await OnSubmit.InvokeAsync(new SubmitEventArgs()
        {
        });

        StateHasChanged();
    }

    protected string GetCurrentState()
    {
        if (FindNextVisible(CurrentStep, i => i - 1) == null)
            return "first";

        if (FindNextVisible(CurrentStep, i => i + 1) == null)
            return "last";

        return "between";
    }


    protected bool CanJumpTo(int pIndex)
    {
        if (EnableJumpToAnyStep)
            return true;

        if (FindNextVisible(CurrentStep, i => i - 1) == pIndex)
            return true;

        if (FindNextVisible(CurrentStep, i => i + 1) == pIndex)
            return true;

        return false;
    }


    public void InvokeStateHasChanged()
    {
        StateHasChanged();
    }

    protected int? FindNextVisible(int pStartIndex, Func<int, int> pModifier)
    {
        int index = pStartIndex;

        while (true)
        {
            index = pModifier(index);

            if (index < 0 || index >= mSteps.Count)
                return null;

            if (mSteps[index].IsVisible)
                return index;
        }
    }

    public void SetCurrentStep(int pIndex, bool pUserInteract)
    {
        if (FreezeCurrentStep)
            return;

        Task.Run(async () =>
        {

            await mLocker.WaitAsync();
            try
            {
                if (pIndex == CurrentStep)
                    return;

                int oldStep = CurrentStep;
                int newStep = pIndex;

                var args = new StepChangedArgs()
                {
                    OldStepIndex = oldStep,
                    NewStepIndex = newStep,
                    OldStep = mSteps[oldStep],
                    NewStep = mSteps[newStep],
                    UserInteract = pUserInteract
                };

                await InvokeAsync(async () =>
                {
                    await OnStepChanged.InvokeAsync(args);
                });

                if (args.Cancelled)
                    return;

                CurrentStep = newStep;

                await InvokeAsync(() =>
                {
                    StateHasChanged();
                });
            }
            finally
            {
                mLocker.Release();
            }
        });
    }

}
